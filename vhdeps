#!/usr/bin/env python3

# Copyright 2018 Delft University of Technology
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import sys
import argparse

from vhdeps_lib import *

parser = argparse.ArgumentParser(
    usage='%s [flags] <sim/synth target> [toplevel ...]' % sys.argv[0],
    description='This script is a VHDL dependency analyzer. Given a list '
    'of VHDL files and/or directories containing VHDL files, it can '
    'generate a compile order and output this in various formats, such '
    'as a TCL file to be sourced by a Modelsim-compatible simulator. '
    'Specify --targets to list the available targets/output formats. '
    'In addition, this script can check some style rules, and prevents '
    'accidental black-box insertion due to missing entities for component '
    'declarations, by making you explicitly opt out of this behavior when '
    'necessary.')

# Positional arguments.
parser.add_argument(
    'target', metavar='target',
    nargs='?', default=None,
    help='Target simulator/synthesizer. Specify --targets to print the '
    'list of supported targets.')

parser.add_argument(
    'entity', metavar='entity',
    nargs='*',
    help='Entity required to be compiled, prefixed with the library name '
    'if not \'work\'.')

# Source directory specifications. At least one of these should be
# specified for this program to do anything useful.
parser.add_argument(
    '-i', '--include', metavar='{{version:}lib:}path',
    action='append', default=[],
    help='Recursively includes (paths containing) arbitrary VHDL files.')

parser.add_argument(
    '-I', '--strict', metavar='{lib:}path', 
    action='append', default=[],
    help='Recursively includes (paths containing) VHDL files, enforcing '
    'style rules. Specify --style for more information.')

parser.add_argument(
    '-x', '--external', metavar='{{version:}lib:}path',
    action='append', default=[],
    help='Recursively includes (paths containing) "external" VHDL files. '
    'These are allowed to define black-box components. Useful for '
    'interfaces to Verilog or for vendor libraries.')

# Filters.
parser.add_argument(
    '-v', '--version', metavar='version',
    type=int, default=2008,
    help='Maximum supported VHDL version, specified as 2-digit or 4-digit '
    'year. Default 2008. Used to filter files included using -I/--strict '
    'based on filename modifiers.')

parser.add_argument(
    '-y', '--synthesis',
    action='store_true',
    help='Target is synthesis instead of simulation. Used to filter files '
    'included using -I/--strict based on filename modifiers.')

# Output control.
parser.add_argument(
    '-o', '--outfile',
    default=None,
    help='Output file. If not specified, stdout is used.')

# Help information.
parser.add_argument(
    '--targets',
    action='store_true',
    help='List the supported targets.')

parser.add_argument(
    '--style',
    action='store_true',
    help='Print information about the VHDL style rules enforced by '
    '--strict.')

# Parse the command line.
args = parser.parse_args()

# Print additional information and exit if requested using --targets or
# --style. --help also falls within this category, but argparse handles
# that internally.
if args.targets:
    print_targets()
    sys.exit(0)

if args.style:
    print('The following style rules are enforced by -I/--strict:')
    print(' - Each VHDL file must define exactly one entity or exactly one package.')
    print(' - VHDL package names must use the _pkg suffix.')
    print(' - The filename must match the name of the VHDL entity/package.')
    print(' - The filename must match "*.<version>.*", where <version> is an integer')
    print('   specifying the version of the VHDL file (93, 2008, etc)')
    print(' - The filename must match "*.i.*" and/or "*.y.*" to indicate inclusion')
    print('   in simulation resp. synthesis contexts.')
    sys.exit(0)

# Select the target.
if args.target is None:
    print('Error: no target specified.', file=sys.stderr)
    parser.print_usage()
    sys.exit(1)
target = get_target(args.target)

# Parse the maximum supported VHDL version.
if args.version < 80:
    max_version = 2000 + args.version
elif args.version < 100:
    max_version = 1900 + args.version
else:
    max_version = args.version

# Construct the list of VHDL files.
l = VhdList(simulation=target.is_simulation(), max_version=max_version)

try:

    # Add the specified files/directories to the VHDL file list.
    def add_dir(arglist, **kwargs):
        for p in arglist:
            p = p.split(':', maxsplit=2)
            fname   = p[-1]
            lib     = 'work' if len(p) < 2 else p[-2]
            version = args.version if len(p) < 3 else int(p[-3])
            if os.path.isdir(fname):
                l.add_dir(fname, lib, version=version, **kwargs)
            else:
                l.add_file(fname, lib, version=version, **kwargs)

    add_dir(args.include)
    add_dir(args.strict, strict=True)
    add_dir(args.external, allow_bb=True)

    # Determine the compile order.
    order = l.order(args.entity)

except StyleError as e:
    print('Style error: %s' % e, file=sys.stderr)
    sys.exit(1)
except ResolutionError as e:
    print('Resolution error: %s' % e, file=sys.stderr)
    sys.exit(1)

if not order:
    print('Error: no VHDL files found.', file=sys.stderr)
    sys.exit(1)

# Run the selected target with the selected output file or stdout.
if args.outfile is None:
    target.run(l, order, sys.stdout)
else:
    with open(args.outfile, 'w') as f:
        target.run(l, order, f)
